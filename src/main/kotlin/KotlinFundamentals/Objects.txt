Objects

    Don't have to have a name like a class does in the expression
    object declaration: like example2 or example3 //  only has one instance and is initialized when it is first accessed
    objects don't have constructors
    you initialize the properties and methods in the body of the object
    you access the data and methods through the class name
    example1 is an object expression/instance
    making something as a companion object in the class makes the methods inside that object accessible to the outer class methods and properties
    use object keyword instead of class keyword, but use the same as you would in building a class definition


example1 expression/instance/anonymous:
    val simple = object {
        val name = "frank"
        fun printName () { printLn(name }
        }

    use
        simple.printName

example2 Singleton/Named object:
    object Logger {
        fun debug(message: String){do stuff}
    }

    class Person {
        fun doWork () {
            Logger.debug("deBug message here")
        }
        companion object Logger {
            fun doThings() {
            println("doing things")
            }
        }
    }
    }

example 3:
    object NetworkInfo {
    }

    like statics in other languages / meaning calling it through the class name

class User private constructor(val name: String) {
   companion object Builder {
        fun build (fName: String, lName: String): User{
            return User(name = "$fName $lName")
        }
    }
}
in the code above if you don't have val/var in the class constructor, you will not have access to it when you instance it

Singleton Pattern
is one single thing in the application

object Printer {
    fun print() {
     println("Printing")
    }
}

call
Printer.print()
only one instance is created.
you don't need to instance it

It can also implement interfaces like
interface Printer {
    fun print()
}

object PrinterImpl: Printer {
    override print() {
        println("printing impl")
    }
}

adding the companion word to the object makes it, so it's easier to access with in a class
it makes it, so you don't have to use the companion object name, you can just use the class name and access the methods in
the object you need
 val logger1 = ClassLogger.Warn.buildWarning()

class ClassLogger(): Logger {
    override fun log() {
        println("Class Logger")
    }
    companion object Warn {
        fun buildWarning() {
            println("WARN")
        }
    }
}

