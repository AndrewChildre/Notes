Higher Order functions and lambdas

    A higher order function is a function that takes a function as a parameter

    Notes:
       to pass a function as an argument, you wrap it in curly braces in the function parameters
        below the action parameter is a type, that type is a function signature

        A lambda is always surrounded by curly braces, specifies parameters, and provides a body of the lambda which
        contains the actual logic
       this is a function literal ->  { x: Int, y: Int -> x + y }

    Functions as arguments:
        fun foo(bar: Int, action: (Int)->Unit) {}

        fun someFunction(num: Int){} //Some function can be passed to foo because it matches the signature for it

        foo(23, { a -> someFunction(a) }) //when you pass a function as an argument, you wrap it in curly braces

        foo(23) { a -> someFunction(a) } if the function parameter is the last parameter you can move it outside the parens

        foo(23, {someFunction(it)}) you don't have to declare the variable like above, if it only has one. You can use "it"

        foo(23) {someFunction(it)} the compiler already knows what it is


       Can also do in-line code aka lambda
        foo(23, { a -> do something with a here })
        foo(23) {do something with "it" here}

        you can move the last parameter outside the () if it is a lambda

        if it's the only parameter you can lose the () on the function and just use  {}


  Function References/Scoping:
        fun foo(bar: Int, action: (Int)->Unit) {}

        class Bar {
            someOtherFunction() {}
        }
        fun someFunction(){}

        foo(23, ::someFunction) scoping operator this is at the top level, it's not in a class

        val b = Bar()
        foo(23, b::someOtherFunction) this is in the Bar class

        the below is the same
        people.maxByOrNull(Person::age)
        people.maxByOrNull {p: Person -> p.age }

    Fibonacci example:

        calling Fib:
            fibonacci(8,{ println(it)})
            fibonacci(8) { println(it)}
            fibonacci(8) {n -> println(n)} n here is the value getting passed to the println function
                    don't get confused here "it" is not 8 or the first parameter it is "current" coming out of the for loop where action is called
                    // the second parameter is the action function println doesn't return a value, but it's getting passed "current" which is an Int

            fun fibonacci(limit: Int, action: (Int) -> Unit) {
                var prev = 0
                var prevprev = 0
                var current = 1

                for (i in 1..limit) {
                    action(current)

                    var temp = current
                    prevprev = prev
                    prev = temp
                    current = prev + prevprev
                }
            }
    Line Logger function example:
        fun lineLogger(block: ()->{}){
        repeat(5){println("-------")
        block()
        println("done")
        }

    call lineLogger
            linelogger {
            println("message")
            }
            lineLogger is called here with a lambda....it does not need the perens when called because of the function parameter
            the curly braces is what calls the lambda it could be lineLogger({println("message")}) but it removes it for the kotlin language
-----------------------------------------
Lambdas

this is a function literal ->  { x: Int, y: Int -> x + y } and you can assign it to a veriable
val sum = { x: Int, y: Int -> x + y } this is a raw lambda
call it like sum(5, 3) would return 8
    it defines a function as a value
    so it looks like this
    list.filter{it > 10}
    {it > 10} is the function literal
    it's passed directly to the filter method as an argument
    returned from the function
    stored in a variable
    used inline

    think of it like
    println(42)
    list.map{it * 2}
    both are expressions passed along immediately

    the opposite of the literal would be a statement like a regular function
    it doesn't produce a value and cant be passed any where

    when the lambda only has one parameter kotlin allows you to use the "it" keyword
    instead of list.map{num -> num * 2}
    use list.map {it * 2}
    the above is trailing lambda syntax it would normally look like list.map({it * 2})
    but since it's the last parameter we can lose/move it outside the perens

    so really .map .list .filter methods are higher order methods but everyone calls them lambdas.
    they are higher order methods because they take a method as a parameter.

    in msl it does have its own .map method in our Outcome class, but otherwise it would use the standard one.

    expression definition = produces a value, can be used right where it appears

    trying to clarify
    in the method parameter we define the method signature like (String) -> Unit
    the lambda is the actual call
    so the definition is
    fun transformString(input: String, action: (String) -> String) { ... }
    and the lambda is
    transformString("frank") {it.reversed()}
    but remember that a lot of methods only have one parameter that is a method signature
    so you can do the trailing lambda syntax